rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * ConnectVerse Security Rules
     *
     * CORE PHILOSOPHY:
     * This ruleset enforces a strict user-ownership model for personal data and a denormalized, role-based 
     * model for community-driven interactions. By prioritizing authorization independence, we ensure 
     * high performance and security without relying on recursive lookups.
     *
     * DATA STRUCTURE:
     * - /users/{userId}: Root profiles and personal data trees (notifications, stories, XP history).
     * - /communities/{communityId}: Shared spaces with denormalized member/role mappings.
     * - /friendships: Relational bridge between users for social discovery.
     * - /calls, /reports: Action-oriented collections for interactions and safety.
     *
     * KEY SECURITY DECISIONS:
     * 1. DENORMALIZATION: Critical authorization data (like community roles or owner IDs) is copied 
     *    directly onto child documents (Messages, Channels) to avoid slow get() calls.
     * 2. FLEXIBLE PROTOTYPING: We enforce 'who' can write, but we do not enforce the 'shape' of 
     *    the data, allowing for rapid schema iteration.
     * 3. RELATIONAL INTEGRITY: We strictly validate that creator/owner IDs in the data match 
     *    the authenticated user during creation and remain immutable during updates.
     */

    // --- Global Helper Functions ---

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    // Removed unused function `isOneOf` to resolve the warnings.
    // function isOneOf(uids) {
    //   return isSignedIn() && request.auth.uid in uids;
    // }

    function isCommunityMember(memberRoles) {
      return isSignedIn() && memberRoles[request.auth.uid] != null;
    }

    // --- Collection Rules ---

    /**
     * @description Public profile discovery and owner-only profile management.
     * @path /users/{userId}
     * @allow (get, list) All authenticated users can see profiles for social features and leaderboards.
     * @deny (create, update) User 'A' trying to edit User 'B's profile.
     * @principle Self-creation and ownership for root user documents.
     */
    match /users/{userId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Private user notifications.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow (create, update, delete, list) User 'A' accessing their own notification center.
       * @deny (list) User 'B' trying to peek at User 'A's notifications.
       * @principle Path-based isolation for private user subcollections.
       */
      match /notifications/{notificationId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Personal stories shared with friends.
       * @path /users/{userId}/stories/{storyId}
       * @allow (get, list) Friends of User 'A' reading their stories via denormalized friend map.
       * @deny (update) A friend trying to edit the story caption.
       * @principle Ownership for writes; Shared Access for reads via denormalization.
       */
      match /stories/{storyId} {
        allow get: if isSignedIn() && (isOwner(userId) || resource.data.viewableByFriendIds[request.auth.uid] == true);
        allow list: if isOwner(userId); // Lists are primarily for the owner; friends find stories via querying.
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Detailed XP history for interactive boards and level tracking.
       * @path /users/{userId}/xp_history/{xpActivityId}
       * @allow (list) User 'A' viewing their own history of XP gains.
       * @deny (create) User 'B' trying to inject fake XP records into User 'A's history.
       * @principle Path-based ownership for high-fidelity personal history logs.
       */
      match /xp_history/{xpActivityId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update, delete: if false; // History records should be immutable for integrity.
      }

      /**
       * @description Records of achievements unlocked by the user.
       * @path /users/{userId}/achievements/{userAchievementId}
       * @allow (get) Any user can see another's achievements if profiles are public.
       * @deny (create) Direct client-side creation (should be handled by backend logic/triggers).
       * @principle Public read-only visibility for social proof; restricted writes.
       */
      match /achievements/{userAchievementId} {
        allow get, list: if isSignedIn();
        allow create, update, delete: if isOwner(userId); // Prototyping allows client side for now.
      }

      /**
       * @description Private AI-generated tools and suggestions.
       * @path /users/{userId}/ai_suggestions/{suggestionId}
       * @allow (get, list, update) User managing their own tool context.
       * @deny (get) Public access to private AI context.
       * @principle Strict private ownership.
       */
      match /ai_suggestions/{suggestionId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Friendship relationships between two users.
     * @path /friendships/{friendshipId}
     * @allow (list) Finding friendships where the current user is the requester or addressee.
     * @deny (create) Creating a friendship for two other random users.
     * @principle Collaborative access for participants.
     */
    match /friendships/{friendshipId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.addresseeId);
      allow list: if isSignedIn(); // Queries must filter by requesterId or addresseeId.
      allow create: if isSignedIn() && request.resource.data.requesterId == request.auth.uid;
      allow update: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.addresseeId);
      allow delete: if isSignedIn() && (request.auth.uid == resource.data.requesterId || request.auth.uid == resource.data.addresseeId);
    }

    /**
     * @description Community management and role-based access.
     * @path /communities/{communityId}
     * @allow (get) Public communities can be viewed; private ones require membership.
     * @deny (update) Non-owners trying to rename the community.
     * @principle Shared access via member maps; owner-only configuration.
     */
    match /communities/{communityId} {
      allow get: if isSignedIn() && (resource.data.isPublic || isCommunityMember(resource.data.memberRoles));
      allow list: if isSignedIn(); // Users typically discover public communities or are invited.
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;

      /**
       * @description Channels within a community using denormalized context.
       * @path /communities/{communityId}/channels/{channelId}
       * @allow (get) Access if community is public or user is in 'allowedMemberIds'.
       * @deny (create) Regular members trying to create new channels.
       * @principle Authorization independence using denormalized parent data.
       */
      match /channels/{channelId} {
        allow get, list: if isSignedIn() && (resource.data.communityIsPublic || isCommunityMember(resource.data.communityMemberRoles));
        allow create: if isSignedIn() && (request.resource.data.communityOwnerId == request.auth.uid);
        allow update: if isSignedIn() && (resource.data.communityOwnerId == request.auth.uid);
        allow delete: if isSignedIn() && (resource.data.communityOwnerId == request.auth.uid);

        /**
         * @description Chat messages with sender ownership and moderator overrides.
         * @path /communities/{communityId}/channels/{channelId}/messages/{messageId}
         * @allow (create) Community members sending messages.
         * @deny (delete) User 'A' trying to delete User 'B's message.
         * @principle Author ownership for writes; membership access for reads.
         */
        match /messages/{messageId} {
          allow get, list: if isSignedIn() && (resource.data.communityIsPublic || isCommunityMember(resource.data.communityMemberRoles));
          allow create: if isSignedIn() && isCommunityMember(request.resource.data.communityMemberRoles) && request.resource.data.senderId == request.auth.uid;
          allow update: if isSignedIn() && (resource.data.senderId == request.auth.uid || resource.data.communityOwnerId == request.auth.uid);
          allow delete: if isSignedIn() && (resource.data.senderId == request.auth.uid || resource.data.communityOwnerId == request.auth.uid);

          match /reactions/{reactionId} {
            allow get, list: if isSignedIn();
            allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
            allow update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
          }
        }
      }

      match /roles/{roleId} {
        allow get, list: if isSignedIn() && isCommunityMember(resource.data.communityMemberRoles);
        allow create, update, delete: if isSignedIn() && request.resource.data.communityOwnerId == request.auth.uid;
      }

      match /user_roles/{userRoleId} {
        allow get, list: if isSignedIn() && isCommunityMember(resource.data.communityMemberRoles);
        allow create, update, delete: if isSignedIn() && request.resource.data.communityOwnerId == request.auth.uid;
      }

      match /invite_links/{inviteId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn() && isCommunityMember(resource.data.communityMemberRoles);
        allow create, update, delete: if isSignedIn() && (request.resource.data.communityOwnerId == request.auth.uid);
      }
    }

    /**
     * @description Media metadata management by uploaders.
     * @path /media_attachments/{mediaId}
     * @allow (create) Any authenticated user uploading a file.
     * @deny (delete) Deleting someone else's media attachment metadata.
     * @principle Individual ownership for user-uploaded content.
     */
    match /media_attachments/{mediaId} {
      allow get: if isSignedIn();
      allow list: if false; // Media listing is usually handled via message/story parent links.
      allow create: if isSignedIn() && request.resource.data.uploaderId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.uploaderId == request.auth.uid;
    }

    /**
     * @description Call session details for active participants.
     * @path /calls/{callId}
     * @allow (get) Initiators or participants viewing call details.
     * @deny (get) Non-participants trying to access call data.
     * @principle Shared access for closed collaborators (participants).
     */
    match /calls/{callId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.initiatorId || request.auth.uid in resource.data.participantIds);
      allow list: if false; // Prevent scanning calls.
      allow create: if isSignedIn() && request.resource.data.initiatorId == request.auth.uid;
      allow update: if isSignedIn() && (request.auth.uid == resource.data.initiatorId || request.auth.uid in resource.data.participantIds);
      allow delete: if false; // Call history should be preserved.
    }

    /**
     * @description Moderation reports.
     * @path /reports/{reportId}
     * @allow (create) Victims or witnesses reporting content.
     * @deny (get) Regular users browsing other people's reports.
     * @principle Reporter-only access for privacy and safety.
     */
    match /reports/{reportId} {
      allow get: if isSignedIn() && resource.data.reporterId == request.auth.uid;
      allow list: if isSignedIn(); // Filtering by reporterId is required.
      allow create: if isSignedIn() && request.resource.data.reporterId == request.auth.uid;
      allow update, delete: if false; // Reports are typically immutable once sent to admins.
    }

    /**
     * @description Global achievement definitions.
     * @path /achievements/{achievementId}
     * @allow (get, list) All users can browse possible achievements.
     * @deny (create, update) Clients trying to modify global game definitions.
     * @principle Public read-only for shared game constants.
     */
    match /achievements/{achievementId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false; // Admin-only via privileged environment or separate collection.
    }

  }
}